Numpy方法和Python方法：
    Numpy 有一个C/C++的API，算法是通过C/C++实现的，
    因此在数学运算上比起使用python方法更加省时，内存占有更小

一、多维数组对象：
    一个ndarray是一个通用的 多维 同类 数据容器
    包含的所有元素都是同一类型

    ndarray都有一个shape属性，表示每一维度的数量；
           都有一个dtype属性，用于描述数组的数据类型
        
    1.ndarray的生成：
        数组生成函数：
            array(data,dtype,****,subok) ----------------------------- 将输入数据（列表，元组，数组等）转化为ndarray，
                                                                        如不显式指明数据类型，则自行断定，；默认复制所有的输入数据
            asarray(data) --------------------------------------------- 将数据转换为ndarray，但是如果输入已经是ndarray则不再复制
            arange(start=0,stop,step=1) ------------------------------- python函数range()的数组版，返回一个一维数组
            ones(shape,dtype,order) ----------------------------------- 按照shape和dtype，生成一个全部是1的数组，储存的优先级是order:('C'/'F')
            ones_like(a,dtype,order,subok,shape) ---------------------- 按照a的shape和dtype生成全部是1的数组，sub表示是否使用其属性，默认True，
                                                                        Flase则全部转化为ndarray
            zeros(shape,dtype,order) ---------------------------------- 同ones，不过全部为0
            zeros_like(a,dtype,order,subok,shape)---------------------- 同ones_like，不过全部为0
            empty(shape,dtype,order) ---------------------------------- 同上，不过全部是垃圾值
            empty_like(a,dtype,order,subok,shape)---------------------- 同上，不过全部为垃圾值
            full(shape,value,dtype,order) ----------------------------- 同上，不过全部为value
            full_like(a,value,dtype,order,subok,shape) ---------------- 同上，不过全部为value
            eye(N,M,k,dtype,order) ------------------------------------ 生成一个对角线全部是1，其他位置全部是0的ndarray，
                                                                        N表示行数，M表示列数（默认=N），k表示第几条对角线，正为上对角线，否则为下对角线
    2.ndaaray的数据类型：
            ?       bool_	    布尔型数据类型（True 或者 False）
                    int_	    默认的整数类型（类似于 C 语言中的 long，int32 或 int64）
                    intc	    与 C 的 int 类型一样，一般是 int32 或 int 64
                    intp	    用于索引的整数类型（类似于 C 的 ssize_t，一般情况下仍然是 int32 或 int64）
            i1      int8	    字节（-128 to 127）
            i2      int16	    整数（-32768 to 32767）
            i4      int32	    整数（-2147483648 to 2147483647）
            i8      int64	    整数（-9223372036854775808 to 9223372036854775807）
            u1      uint8	    无符号整数（0 to 255）
            u2      uint16	    无符号整数（0 to 65535）
            u4      uint32	    无符号整数（0 to 4294967295）
            u8      uint64	    无符号整数（0 to 18446744073709551615）
                    float_	    float64 类型的简写
            f2      float16	    半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位
            f4/f    float32	    单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位
            f8/d    float64	    双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位，和Python的float兼容
                    complex_	complex128 类型的简写，即 128 位复数
            c8      complex64	复数，表示双 32 位浮点数（实数部分和虚数部分）
            c16     complex128	复数，表示双 64 位浮点数（实数部分和虚数部分）
            S       string_     修正的ASCII字符串类型，会自动设置长度，例如生成一个长度为10的字符串类型为‘S10’
            U       Unicode_    修正的Unicode类型，会自动设置长度，生成一个长度为10的Unicode类型，使用‘U10’

                numpy 的数值类型实际上是 dtype 对象的实例，并对应唯一的字符，包括 np.bool_，np.int32，np.float32，等等。
            
            astype(dtype) ------------------------------------ 生成一个新数组，将原数组的元素强制性的转化为dtype
                PS：dtype也可以是Python内置的类型，会转换到对应的数据类型
            
    3.数组运算：
        省去Python中循环的工作，速度加快10~100倍
        同时数组还有自己的性质，通过迭代器迭代其中的每一个元素实现运算，包括比较
        可以实现以下的向量化运算
            向量化：
            数组和数组的加减运算 -------- 向量与向量的加减运算
            数组和标量的乘法 ------------ 向量和标量的乘法
            数组 = 标量 ---------------- 数组的所有元素都是该标量
            
    4.索引和切片：
        一维数组的索引和Python列表相似：
        In []:  arr = np.arange(10)
        In []:  arr[5]
        Out[]:  5
        
        多维数组的索引：
            arrayObj[d1][d2]... ---------------- arrageObj的第d1元素的第d2的元素...
            arrayObj[d1,d2,...] ---------------- 同上
                PS：选取的子集都是原数组的视图（视图见下面）

        对于一维数组可以通过类似Python列表切片的方式实现切片：
            PS：数组切片并不是新建一个数组，而是作用于原来的数组上的视图，类似于指针
            In []:  arr[5:8]
            Out[]:  array([5, 6, 7])
            In []:  arr[5:8] = 12
                    arr
            Out[]:  array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])
            In []:  arr_slice = arr[5:8]            # 即便转换了也是一样的
            In []:  arr_slice[1] = 12345
                    arr
            Out[]:  array([0, 1, 2, 3, 4, 12, 12345, 12, 8, 9])
        切片的拷贝：
            sliceObj.copy() --------------------------------- 返回数组切片数据的拷贝
    
    对于多维数组的切片
         和多维数组的索引类似
         arrayObj[range1,range2,...] ----------------------- arrayObj中range1中元素的range2中元素...组成的有层次的数组
        In []:  arr2d = np.array([[1,2,3],[4,5,6],[7,8,9]])
                arr2d
        Out[]:  array([[1, 2, 3],
                       [4, 5, 6],
                       [7, 8, 9]])
        In []:  arr2d[:2]
        Out[]:  array([[1, 2, 3],
                       [4, 5, 6]])
        In []:  arr2d[:2,1:]
        Out[]:  array([[2, 3],
                       [5, 6]])
        In []:  arr2d[1,:2]              # 切片索引中使用了单个数字的索引，会降维
        Out[]:  array([4, 5])
        In []:  arr2d[:2,2]
        Out[]:  array([3, 6])
        In []:  arr2d[:,1]
        Out[]:  array([2, 5, 8])
        In []:  arr2d[:,:1]
        Out[]:  array([[1],
                       [4],
                       [7]])
    
    5.布尔索引：
        in []:  arrayObj == 或 > 或 < Obj 
        Out[]:  BoolArrayObj
        布尔索引是一个全部由bool值组成的一个数组，,其shape由arrayObj决定
        
        array[boolArrayObj] --------------------------------- 返回一个数组，是其中所有的True对应的值组成的视图，
                                                              boolArrayObj的shape必须和array的shape能够对应。
                                                              返回的数组视图是dim(array) - dim(boolArrayObj) +1 维的

        反选 ~ ---------------------------------------------- 在布尔索引之前使用 ~ 可以将所有的bool值相反
        array[~(boolArrayObj)]
        
        由于是视图，bool索引能够方便的更改数组的内容
    
    6.神奇索引：
        按照神奇索引的一维数组参数的顺序，进行筛选
        如果是多个数组a,b,c......产生的索引，可以得到一组坐标(a[0],b[0],c[0]...),(a[1],b[1],c[1]),...
        返回对应的元素

        数组的矩形选择？
        通过一次单个数组的筛选，之后使用[:，[indexs]]，保持维度一定。

        In []:  arr = np.arange(32).reshape((8,4))
        In []:  arr
        Out[]:  array([[ 0,  1,  2,  3],
                       [ 4,  5,  6,  7],
                       [ 8,  9, 10, 11],
                       [12, 13, 14, 15],
                       [16, 17, 18, 19],
                       [20, 21, 22, 23],
                       [24, 25, 26, 27],
                       [28, 29, 30, 31]])
        
        In []:  arr[[1,5,7,2]]
        Out[]:  array([[ 4,  5,  6,  7],
                       [20, 21, 22, 23],
                       [28, 29, 30, 31],
                       [ 8,  9, 10, 11]])
        
        In []:  arr[[1,5,7,2],[0,3,1,2]]
        Out[]:  array([ 4, 23, 29, 10])

        In []:  arr[[1,5,7,2]][:,[0,3,1,2]]
        Out[]:  array([[ 4,  7,  5,  6],
                       [20, 23, 21, 22],
                       [28, 31, 29, 30],
                       [ 8, 11,  9, 10]])

    7.数组转置和换轴
        1.ArrayObj.transpose(indexs) ------------------ 将ArrayObj的轴的顺序(0,1,2,3...)，转为(indexs)
        2.ArrayObj.T ---------------------------------- 将二维的ArrayObj进行转置
        3.ArrayObj.swapaxes(index1,index2) ------------ 将index1轴，和index2轴进行转动

        transpose(indexs) 怎么看？

        1.转化成多次的swapaxes(index1,index2)
        2.转动参数之前的部分是大的结构
        3.转动参数之后的部分是单位
        4.之后，换维数，看对应点和内部结构。

二、通用函数 ufunc ：快速逐元素数组函数
    一元通用函数：
        abs,fabs --------------------------------------- 逐元素地计算整数、浮点数或复数的绝对值
        sqrt ------------------------------------------- 逐元素求平方根，（同arr**0.5）
                                                         对于实数数组，负数返回nan
                                                         对于复数数组，返回复数
        square ----------------------------------------- 逐元素求平方，（同arr**2）
        exp -------------------------------------------- 逐元素求自然指数值
        logg,log10,log2,log1p -------------------------- 逐元素求自然对数，10底对数，2底对数，ln(1+x)
        sign ------------------------------------------- 逐元素计算每个元素的符号值，即1，0，-1
        ceil，floor ------------------------------------ 逐元素求向上取值和向下取整
        rint ------------------------------------------- 逐元素保留到整数位，并保持dtype
        modf ------------------------------------------- 逐元素将整数部分和小数部分按照数组部分形成数组
        isnan ------------------------------------------ 逐元素检查数组中元素是否是一个nan，返回一个布尔值数组
        isfinite，isinf -------------------------------- 逐元素检查数组中元素是否有限（非inf，非nan），返回bool值数组
        cos，cosh，sin，sinh，tan，tanh ----------------- 逐元素返回三角曲线，包括复数
        arccos,arccosh,arcsin,arcsinh,arctan,arctanh --- 逐元素返回反三角函数值
        logical_not ------------------------------------ 对数组元素按位取反，同(~arr)

    二元通用函数：
        add -------------------------------------------- 将数组的对应元素相加
        subtract --------------------------------------- 逐元素将第一个数组中的元素减去第二个数组中的元素
        multiply --------------------------------------- 逐元素将对应元素相乘
        divide,floor_divide ---------------------------- 逐元素将第一个数组中的元素除以（或整除）第二个数组中的元素
        mod -------------------------------------------- 逐元素进行求模计算
        power ------------------------------------------ 逐元素将第一个数组中的元素乘幂第二个数组中的元素
        maximum，fmax ---------------------------------- 逐个元素比较最大值，fmax忽略nan
        minimum，fmin ---------------------------------- 逐个元素比较最小值，fmin忽略nan
        copysign --------------------------------------- 逐元素将第一个数组中的元素的符号，设置为第二个数组中的元素符号
        greater，greater_equal,less,
        less_equal,equal,not_equal, -------------------- 逐元素进行比较，返回bool数组
        logical_and,logical_or,logical_xor ------------- 逐元素进行逻辑（位）操作 同&，|，^
    通用函数一般返回的都是数组的拷贝，可以通过其中的out参数，将拷贝数组赋值（如自己给自己赋值）
三、使用数组面向数组编程：
    numpy.meshgrid(*xi,copy,sparse,indexing) ----------- 返回对应的坐标矩阵
                                                         xi是每个维度对应网格坐标的一维数组
                                                         copy ：bool，表示是否拷贝，默认False
                                                         sparse：bool, 表示是否采用缩略的形式，默认False
                                                         indexing：矩阵的模式，有xy和ij模式
                                                                    xy： 返回一个 N2，N1，N3，N4……的矩阵
                                                                    ij:  返回一个 N1, N2, N3,N4……的矩阵
    条件逻辑:
    numpy.where(cond,arr1,arr2) ------------------------ 如果cond布尔矩阵对应值是True，则对应位置取arr1对应元素的值，
                                                                               反之取arr2对应元素的值
                                                        类似 np.array([(x if c else y) for x,y,c in zip(arr1,arr2,cond)])

        PS: where 相比于右边的python方法可以解决二维以上的问题
            where 的参数除了大小相同的数组，也可以使用标量，表示按照bool数组的结构填写对应的标量值

    基本统计方法：
        sum(axis) -------------------------------------- 沿着轴向计算所有元素的和，默认全求返回一个数，0长度的数组，累和为0
        mean(axis) ------------------------------------- 数学平均，0长度的数组平均值是nan
        std,var ---------------------------------------- 标准差和方差，可以选择自由度调节
        min，max --------------------------------------- 最小值和最大值
        argmin，argmax --------------------------------- 最小值和最大值的位置
        cumsum ----------------------------------------- 从0开始累积和，不会聚合
        cumprod ---------------------------------------- 从1开始累积积，不会聚合
    布尔数组的方法：
        BoolArrayObj.sum() ----------------------------- 计数BoolArrayObj中True的个数
        BoolArrayObj.any() ----------------------------- 检查数组中是否有一个True
        BoolArrayObj.all() ----------------------------- 检查数组中是否全部是True
            PS：也可以用于非布尔数组，0表示Fasle，非0表示True
    排序方法：
        ArrayObj.sort(axis) ---------------------------- 在原数组上对数组元素沿轴向进行排序，默认最低维度
        numpy.sort(axis) ------------------------------- 同上，但是返回排序好了的数组拷贝
    唯一值和集合逻辑：（对一维数组）
        unique(arr) ------------------------------------ 计算arr元素中的唯一值，并排序
        intersect1d(arr1,arr2) ------------------------- 计算arr1和arr2的元素的交集，并排序
        union1d(arr1,arr2) ----------------------------- 计算arr1和arr2的元素的并集，并排序
        in1d(arr1,arr2) -------------------------------- 计算arr1的元素是否在arr2中，并返回一个bool数组
        setdiff1d(arr1,arr2) --------------------------- 差集，在arr1中而不在arr2中的元素
        setxor1d(arr1,arr2) ---------------------------- 异或集，在arr1或arr2中，但是不在arr1,arr2交集中的元素

四、使用数组进行文件输入和输出
    np.save(filename,arr) ----------------------------------- 将数组作为数据，存储为npy文件，没加npy后缀时自动添加
    np.load(filename) --------------------------------------- 返回一个对应数据和结构的数组
    np.savez(filename,key1=arr1,key2=arr2,...) -------------- 将arr1,arr2...存储为一个类似字典的文件，key1,key2...是其对应的键
    np.savez_compressed(filename,key1=arr1,key2=arr2...) ---- 将数据存入已 经压缩的文件
    
五、线性代数：
    numpy中有以下的基本函数：
        X.dot(Y)/np.dot(X,Y)/X@Y -------------------------------- 矩阵相乘
        diag(X)/X.diagonal() ------------------------------------ 将方阵中的对角元素提出来，组成一个一维为数组
                                                                  或者将一个一维数组转化为作为对角线的方阵
        trace(X)/X.trace() -------------------------------------- 方阵对角元素求和
    以下的函数来自numpy.linalg库：
        det(X) -------------------------------------------------- 计算矩阵的行列式
        eig(X) -------------------------------------------------- 计算X的特征值和特征向量,返回一个两个数组的元组，第一个是特征值，第二个是特征向量
        inv(X) -------------------------------------------------- 逆矩阵
        pinv(X) ------------------------------------------------- 计算矩阵的Moore-Penrose伪逆
        qr(X) --------------------------------------------------- 施密特正交化，返回两个数组的元组，第一个是q，第二个是r（上三角矩阵）
        svd(X) -------------------------------------------------- 奇异值分解
        solve(A，B) --------------------------------------------- 返回AX = B的解
        lstsq(A,B) ---------------------------------------------- 返回Ax = B的最小二乘解
六、伪随机数生成函数：
    numpy.random库扩展了Python的random库，可以得到多种概率分布下的完整样本数组
    seed(Seed) -------------------------------------------------- 设置随机数的种子
    RandomState(Seed) ------------------------------------------- 创建一个随机数生成器
    permutation(array/int) -------------------------------------- 若是int，则返回对应的arange(int)数组随机排序
                                                                  若是array，则返回array的随机排列
    shuffle(array) ---------------------------------------------- 随机排列一个序列，改变原有序列
    rand(shape) ------------------------------------------------- 均匀分布中抽取样品
    randint(low,high) ------------------------------------------- 返回一个数组，返回对应阈值之间的均匀随机数组成的数组
                                                                  若low或high是一个int，是一个固定的边界值
                                                                  若low或high是一个N，M维数数组，则是对应的数组
    randn(shapes) ----------------------------------------------- 从均值0方差为1的正态分布中抽取样本
    binomial(n,p,times) ----------------------------------------- 从二项分布中抽取样本，n为单次测量次数，p为概率，times为数组长度
    normal(loc,scale,size) -------------------------------------- 从正态分布中抽取样本，locat是均值，scale是标准差，size为数组形状
    beta(a,b,size) ---------------------------------------------- 从beta分布中抽取样本
    chisquare(df,size) ------------------------------------------ 从卡方分布中抽取样本
    gamma() ----------------------------------------------------- 从伽马分布中抽取样本
    uniform(low,high) ------------------------------------------- 从low到high的均匀分布中抽取样本





